/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package cz.jkozlovsky.scala.protobuf.field.extractor

import com.google.protobuf.Descriptors.FieldDescriptor
import com.google.protobuf._

import java.io.InputStream
import java.nio.ByteBuffer

object FieldExtractor {

  /** Calling this before extraction should enable the unsafe mode within the JVM, making it possible
    * to further speed up the extraction process in some cases. */
  def enableUnsafe(): Unit = classOf[sun.misc.Unsafe]
    .getDeclaredField("theUnsafe")
    .setAccessible(true)

  /** Extracts the provided field statically.
    *
    * This means that you have to explicitly provide an extraction method for the requested data type, but since it
    * will be directly compiled as an argument, it should be actually faster than using the dynamic approach.
    */
  def staticExtract[T](codedInputStream: CodedInputStream, fieldDescriptor: FieldDescriptor, extractionMethod: CodedInputStream => T): T = {
    while (!codedInputStream.isAtEnd) {
      if (WireFormat.getTagFieldNumber(codedInputStream.readTag()) == fieldDescriptor.getNumber) {
        return extractionMethod.apply(codedInputStream)
      } else codedInputStream.skipField(codedInputStream.getLastTag)
    }
    fieldDescriptor.getDefaultValue.asInstanceOf[T]
  }

  /** Extracts the provided field dynamically.
    *
    * This means that we dynamically create an extraction method, which is then used for static extraction.
    *
    * This approach might create unnecessary overhead during extractor creation, but it should be noticeable only during
    * parsing of the first message, since we store the extractor in an final implicit class value.
    */
  def dynamicExtract[T](codedInputStream: CodedInputStream, fieldDescriptor: FieldDescriptor): T = staticExtract(
    codedInputStream, fieldDescriptor, fieldDescriptor.extractor
  ).asInstanceOf[T]

  implicit class WithFieldDescriptor(fieldDescriptor: FieldDescriptor) {
    final val extractor: CodedInputStream => AnyRef = fieldDescriptor.getType match {
      case FieldDescriptor.Type.BOOL => (codedInputStream: CodedInputStream) => codedInputStream.readBool().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.BYTES => (codedInputStream: CodedInputStream) => codedInputStream.readBytes().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.DOUBLE => (codedInputStream: CodedInputStream) => codedInputStream.readDouble().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.ENUM => (codedInputStream: CodedInputStream) => codedInputStream.readEnum().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.FIXED32 => (codedInputStream: CodedInputStream) => codedInputStream.readFixed32().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.FIXED64 => (codedInputStream: CodedInputStream) => codedInputStream.readFixed64().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.FLOAT => (codedInputStream: CodedInputStream) => codedInputStream.readFloat().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.GROUP => throw new UnsupportedOperationException("Extraction of group is not supported with dynamic extraction.")
      case FieldDescriptor.Type.INT32 => (codedInputStream: CodedInputStream) => codedInputStream.readInt32().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.INT64 => (codedInputStream: CodedInputStream) => codedInputStream.readInt64().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.MESSAGE => throw new UnsupportedOperationException("Extraction of message is not supported with dynamic extraction.")
      case FieldDescriptor.Type.SFIXED32 => (codedInputStream: CodedInputStream) => codedInputStream.readSFixed32().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.SFIXED64 => (codedInputStream: CodedInputStream) => codedInputStream.readSFixed64().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.SINT32 => (codedInputStream: CodedInputStream) => codedInputStream.readSInt32().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.SINT64 => (codedInputStream: CodedInputStream) => codedInputStream.readSInt64().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.STRING => (codedInputStream: CodedInputStream) => codedInputStream.readString().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.UINT32 => (codedInputStream: CodedInputStream) => codedInputStream.readUInt32().asInstanceOf[AnyRef]
      case FieldDescriptor.Type.UINT64 => (codedInputStream: CodedInputStream) => codedInputStream.readUInt64().asInstanceOf[AnyRef]
    }
  }

  /** Use with caution, it might unintentionally slow down the whole extraction process if used unwisely. */
  object WithImplicitCodedInputStream {

    import scala.language.implicitConversions

    implicit def codeInputStream(inputStream: InputStream): CodedInputStream = CodedInputStream.newInstance(inputStream)

    implicit def codeByteBuffer(byteBuffer: ByteBuffer): CodedInputStream = CodedInputStream.newInstance(byteBuffer)

    implicit def codeArrayOfBytes(arrayOfBytes: Array[Byte]): CodedInputStream = CodedInputStream.newInstance(arrayOfBytes)

    implicit def codeIterableOfByteBuffer(byteBuffers: java.lang.Iterable[ByteBuffer]): CodedInputStream = CodedInputStream.newInstance(byteBuffers)
  }
}
